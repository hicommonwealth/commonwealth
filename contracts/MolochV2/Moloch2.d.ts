/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription
} from ".";

interface Moloch2Interface extends Interface {
  functions: {
    proposals: TypedFunctionDescription<{ encode([]: [BigNumberish]): string }>;

    processingReward: TypedFunctionDescription<{ encode([]: []): string }>;

    members: TypedFunctionDescription<{ encode([]: [string]): string }>;

    totalSharesRequested: TypedFunctionDescription<{ encode([]: []): string }>;

    approvedTokens: TypedFunctionDescription<{
      encode([]: [BigNumberish]): string;
    }>;

    totalShares: TypedFunctionDescription<{ encode([]: []): string }>;

    proposalQueue: TypedFunctionDescription<{
      encode([]: [BigNumberish]): string;
    }>;

    proposedToKick: TypedFunctionDescription<{ encode([]: [string]): string }>;

    memberAddressByDelegateKey: TypedFunctionDescription<{
      encode([]: [string]): string;
    }>;

    gracePeriodLength: TypedFunctionDescription<{ encode([]: []): string }>;

    tokenWhitelist: TypedFunctionDescription<{ encode([]: [string]): string }>;

    summoningTime: TypedFunctionDescription<{ encode([]: []): string }>;

    votingPeriodLength: TypedFunctionDescription<{ encode([]: []): string }>;

    proposalDeposit: TypedFunctionDescription<{ encode([]: []): string }>;

    guildBank: TypedFunctionDescription<{ encode([]: []): string }>;

    dilutionBound: TypedFunctionDescription<{ encode([]: []): string }>;

    periodDuration: TypedFunctionDescription<{ encode([]: []): string }>;

    depositToken: TypedFunctionDescription<{ encode([]: []): string }>;

    emergencyExitWait: TypedFunctionDescription<{ encode([]: []): string }>;

    proposalCount: TypedFunctionDescription<{ encode([]: []): string }>;

    proposedToWhitelist: TypedFunctionDescription<{
      encode([]: [string]): string;
    }>;

    submitProposal: TypedFunctionDescription<{
      encode([
        applicant,
        sharesRequested,
        tributeOffered,
        tributeToken,
        paymentRequested,
        paymentToken,
        details
      ]: [
        string,
        BigNumberish,
        BigNumberish,
        string,
        BigNumberish,
        string,
        string
      ]): string;
    }>;

    submitWhitelistProposal: TypedFunctionDescription<{
      encode([tokenToWhitelist, details]: [string, string]): string;
    }>;

    submitGuildKickProposal: TypedFunctionDescription<{
      encode([memberToKick, details]: [string, string]): string;
    }>;

    sponsorProposal: TypedFunctionDescription<{
      encode([proposalId]: [BigNumberish]): string;
    }>;

    submitVote: TypedFunctionDescription<{
      encode([proposalIndex, uintVote]: [BigNumberish, BigNumberish]): string;
    }>;

    processProposal: TypedFunctionDescription<{
      encode([proposalIndex]: [BigNumberish]): string;
    }>;

    ragequit: TypedFunctionDescription<{
      encode([sharesToBurn]: [BigNumberish]): string;
    }>;

    safeRagequit: TypedFunctionDescription<{
      encode([sharesToBurn, tokenList]: [BigNumberish, string[]]): string;
    }>;

    cancelProposal: TypedFunctionDescription<{
      encode([proposalId]: [BigNumberish]): string;
    }>;

    updateDelegateKey: TypedFunctionDescription<{
      encode([newDelegateKey]: [string]): string;
    }>;

    getCurrentPeriod: TypedFunctionDescription<{ encode([]: []): string }>;

    getProposalQueueLength: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    canRagequit: TypedFunctionDescription<{
      encode([highestIndexYesVote]: [BigNumberish]): string;
    }>;

    hasVotingPeriodExpired: TypedFunctionDescription<{
      encode([startingPeriod]: [BigNumberish]): string;
    }>;

    getMemberProposalVote: TypedFunctionDescription<{
      encode([memberAddress, proposalIndex]: [string, BigNumberish]): string;
    }>;
  };

  events: {
    SubmitProposal: TypedEventDescription<{
      encodeTopics([
        proposalIndex,
        delegateKey,
        memberAddress,
        applicant,
        tributeOffered,
        sharesRequested
      ]: [
        null,
        string | null,
        string | null,
        string | null,
        null,
        null
      ]): string[];
    }>;

    SubmitVote: TypedEventDescription<{
      encodeTopics([proposalIndex, delegateKey, memberAddress, uintVote]: [
        BigNumberish | null,
        string | null,
        string | null,
        null
      ]): string[];
    }>;

    ProcessProposal: TypedEventDescription<{
      encodeTopics([
        proposalIndex,
        applicant,
        memberAddress,
        tributeOffered,
        sharesRequested,
        didPass
      ]: [
        BigNumberish | null,
        string | null,
        string | null,
        null,
        null,
        null
      ]): string[];
    }>;

    Ragequit: TypedEventDescription<{
      encodeTopics([memberAddress, sharesToBurn]: [
        string | null,
        null
      ]): string[];
    }>;

    CancelProposal: TypedEventDescription<{
      encodeTopics([proposalIndex, applicantAddress]: [
        BigNumberish | null,
        null
      ]): string[];
    }>;

    UpdateDelegateKey: TypedEventDescription<{
      encodeTopics([memberAddress, newDelegateKey]: [
        string | null,
        null
      ]): string[];
    }>;

    SummonComplete: TypedEventDescription<{
      encodeTopics([summoner, shares]: [string | null, null]): string[];
    }>;
  };
}

export class Moloch2 extends Contract {
  connect(signerOrProvider: Signer | Provider | string): Moloch2;
  attach(addressOrName: string): Moloch2;
  deployed(): Promise<Moloch2>;

  on(event: EventFilter | string, listener: Listener): Moloch2;
  once(event: EventFilter | string, listener: Listener): Moloch2;
  addListener(eventName: EventFilter | string, listener: Listener): Moloch2;
  removeAllListeners(eventName: EventFilter | string): Moloch2;
  removeListener(eventName: any, listener: Listener): Moloch2;

  interface: Moloch2Interface;

  functions: {
    proposals(
      arg0: BigNumberish
    ): Promise<{
      applicant: string;
      proposer: string;
      sponsor: string;
      sharesRequested: BigNumber;
      tributeOffered: BigNumber;
      tributeToken: string;
      paymentRequested: BigNumber;
      paymentToken: string;
      startingPeriod: BigNumber;
      yesVotes: BigNumber;
      noVotes: BigNumber;
      details: string;
      maxTotalSharesAtYesVote: BigNumber;
      0: string;
      1: string;
      2: string;
      3: BigNumber;
      4: BigNumber;
      5: string;
      6: BigNumber;
      7: string;
      8: BigNumber;
      9: BigNumber;
      10: BigNumber;
      11: string;
      12: BigNumber;
    }>;

    processingReward(): Promise<BigNumber>;

    members(
      arg0: string
    ): Promise<{
      delegateKey: string;
      shares: BigNumber;
      exists: boolean;
      highestIndexYesVote: BigNumber;
      0: string;
      1: BigNumber;
      2: boolean;
      3: BigNumber;
    }>;

    totalSharesRequested(): Promise<BigNumber>;

    approvedTokens(arg0: BigNumberish): Promise<string>;

    totalShares(): Promise<BigNumber>;

    proposalQueue(arg0: BigNumberish): Promise<BigNumber>;

    proposedToKick(arg0: string): Promise<boolean>;

    memberAddressByDelegateKey(arg0: string): Promise<string>;

    gracePeriodLength(): Promise<BigNumber>;

    tokenWhitelist(arg0: string): Promise<boolean>;

    summoningTime(): Promise<BigNumber>;

    votingPeriodLength(): Promise<BigNumber>;

    proposalDeposit(): Promise<BigNumber>;

    guildBank(): Promise<string>;

    dilutionBound(): Promise<BigNumber>;

    periodDuration(): Promise<BigNumber>;

    depositToken(): Promise<string>;

    emergencyExitWait(): Promise<BigNumber>;

    proposalCount(): Promise<BigNumber>;

    proposedToWhitelist(arg0: string): Promise<boolean>;

    submitProposal(
      applicant: string,
      sharesRequested: BigNumberish,
      tributeOffered: BigNumberish,
      tributeToken: string,
      paymentRequested: BigNumberish,
      paymentToken: string,
      details: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    submitWhitelistProposal(
      tokenToWhitelist: string,
      details: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    submitGuildKickProposal(
      memberToKick: string,
      details: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    sponsorProposal(
      proposalId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    submitVote(
      proposalIndex: BigNumberish,
      uintVote: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    processProposal(
      proposalIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    ragequit(
      sharesToBurn: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    safeRagequit(
      sharesToBurn: BigNumberish,
      tokenList: string[],
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    cancelProposal(
      proposalId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    updateDelegateKey(
      newDelegateKey: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    getCurrentPeriod(): Promise<BigNumber>;

    getProposalQueueLength(): Promise<BigNumber>;

    canRagequit(highestIndexYesVote: BigNumberish): Promise<boolean>;

    hasVotingPeriodExpired(startingPeriod: BigNumberish): Promise<boolean>;

    getMemberProposalVote(
      memberAddress: string,
      proposalIndex: BigNumberish
    ): Promise<number>;
  };

  proposals(
    arg0: BigNumberish
  ): Promise<{
    applicant: string;
    proposer: string;
    sponsor: string;
    sharesRequested: BigNumber;
    tributeOffered: BigNumber;
    tributeToken: string;
    paymentRequested: BigNumber;
    paymentToken: string;
    startingPeriod: BigNumber;
    yesVotes: BigNumber;
    noVotes: BigNumber;
    details: string;
    maxTotalSharesAtYesVote: BigNumber;
    0: string;
    1: string;
    2: string;
    3: BigNumber;
    4: BigNumber;
    5: string;
    6: BigNumber;
    7: string;
    8: BigNumber;
    9: BigNumber;
    10: BigNumber;
    11: string;
    12: BigNumber;
  }>;

  processingReward(): Promise<BigNumber>;

  members(
    arg0: string
  ): Promise<{
    delegateKey: string;
    shares: BigNumber;
    exists: boolean;
    highestIndexYesVote: BigNumber;
    0: string;
    1: BigNumber;
    2: boolean;
    3: BigNumber;
  }>;

  totalSharesRequested(): Promise<BigNumber>;

  approvedTokens(arg0: BigNumberish): Promise<string>;

  totalShares(): Promise<BigNumber>;

  proposalQueue(arg0: BigNumberish): Promise<BigNumber>;

  proposedToKick(arg0: string): Promise<boolean>;

  memberAddressByDelegateKey(arg0: string): Promise<string>;

  gracePeriodLength(): Promise<BigNumber>;

  tokenWhitelist(arg0: string): Promise<boolean>;

  summoningTime(): Promise<BigNumber>;

  votingPeriodLength(): Promise<BigNumber>;

  proposalDeposit(): Promise<BigNumber>;

  guildBank(): Promise<string>;

  dilutionBound(): Promise<BigNumber>;

  periodDuration(): Promise<BigNumber>;

  depositToken(): Promise<string>;

  emergencyExitWait(): Promise<BigNumber>;

  proposalCount(): Promise<BigNumber>;

  proposedToWhitelist(arg0: string): Promise<boolean>;

  submitProposal(
    applicant: string,
    sharesRequested: BigNumberish,
    tributeOffered: BigNumberish,
    tributeToken: string,
    paymentRequested: BigNumberish,
    paymentToken: string,
    details: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  submitWhitelistProposal(
    tokenToWhitelist: string,
    details: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  submitGuildKickProposal(
    memberToKick: string,
    details: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  sponsorProposal(
    proposalId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  submitVote(
    proposalIndex: BigNumberish,
    uintVote: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  processProposal(
    proposalIndex: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  ragequit(
    sharesToBurn: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  safeRagequit(
    sharesToBurn: BigNumberish,
    tokenList: string[],
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  cancelProposal(
    proposalId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  updateDelegateKey(
    newDelegateKey: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  getCurrentPeriod(): Promise<BigNumber>;

  getProposalQueueLength(): Promise<BigNumber>;

  canRagequit(highestIndexYesVote: BigNumberish): Promise<boolean>;

  hasVotingPeriodExpired(startingPeriod: BigNumberish): Promise<boolean>;

  getMemberProposalVote(
    memberAddress: string,
    proposalIndex: BigNumberish
  ): Promise<number>;

  filters: {
    SubmitProposal(
      proposalIndex: null,
      delegateKey: string | null,
      memberAddress: string | null,
      applicant: string | null,
      tributeOffered: null,
      sharesRequested: null
    ): EventFilter;

    SubmitVote(
      proposalIndex: BigNumberish | null,
      delegateKey: string | null,
      memberAddress: string | null,
      uintVote: null
    ): EventFilter;

    ProcessProposal(
      proposalIndex: BigNumberish | null,
      applicant: string | null,
      memberAddress: string | null,
      tributeOffered: null,
      sharesRequested: null,
      didPass: null
    ): EventFilter;

    Ragequit(memberAddress: string | null, sharesToBurn: null): EventFilter;

    CancelProposal(
      proposalIndex: BigNumberish | null,
      applicantAddress: null
    ): EventFilter;

    UpdateDelegateKey(
      memberAddress: string | null,
      newDelegateKey: null
    ): EventFilter;

    SummonComplete(summoner: string | null, shares: null): EventFilter;
  };

  estimate: {
    proposals(arg0: BigNumberish): Promise<BigNumber>;

    processingReward(): Promise<BigNumber>;

    members(arg0: string): Promise<BigNumber>;

    totalSharesRequested(): Promise<BigNumber>;

    approvedTokens(arg0: BigNumberish): Promise<BigNumber>;

    totalShares(): Promise<BigNumber>;

    proposalQueue(arg0: BigNumberish): Promise<BigNumber>;

    proposedToKick(arg0: string): Promise<BigNumber>;

    memberAddressByDelegateKey(arg0: string): Promise<BigNumber>;

    gracePeriodLength(): Promise<BigNumber>;

    tokenWhitelist(arg0: string): Promise<BigNumber>;

    summoningTime(): Promise<BigNumber>;

    votingPeriodLength(): Promise<BigNumber>;

    proposalDeposit(): Promise<BigNumber>;

    guildBank(): Promise<BigNumber>;

    dilutionBound(): Promise<BigNumber>;

    periodDuration(): Promise<BigNumber>;

    depositToken(): Promise<BigNumber>;

    emergencyExitWait(): Promise<BigNumber>;

    proposalCount(): Promise<BigNumber>;

    proposedToWhitelist(arg0: string): Promise<BigNumber>;

    submitProposal(
      applicant: string,
      sharesRequested: BigNumberish,
      tributeOffered: BigNumberish,
      tributeToken: string,
      paymentRequested: BigNumberish,
      paymentToken: string,
      details: string
    ): Promise<BigNumber>;

    submitWhitelistProposal(
      tokenToWhitelist: string,
      details: string
    ): Promise<BigNumber>;

    submitGuildKickProposal(
      memberToKick: string,
      details: string
    ): Promise<BigNumber>;

    sponsorProposal(proposalId: BigNumberish): Promise<BigNumber>;

    submitVote(
      proposalIndex: BigNumberish,
      uintVote: BigNumberish
    ): Promise<BigNumber>;

    processProposal(proposalIndex: BigNumberish): Promise<BigNumber>;

    ragequit(sharesToBurn: BigNumberish): Promise<BigNumber>;

    safeRagequit(
      sharesToBurn: BigNumberish,
      tokenList: string[]
    ): Promise<BigNumber>;

    cancelProposal(proposalId: BigNumberish): Promise<BigNumber>;

    updateDelegateKey(newDelegateKey: string): Promise<BigNumber>;

    getCurrentPeriod(): Promise<BigNumber>;

    getProposalQueueLength(): Promise<BigNumber>;

    canRagequit(highestIndexYesVote: BigNumberish): Promise<BigNumber>;

    hasVotingPeriodExpired(startingPeriod: BigNumberish): Promise<BigNumber>;

    getMemberProposalVote(
      memberAddress: string,
      proposalIndex: BigNumberish
    ): Promise<BigNumber>;
  };
}
