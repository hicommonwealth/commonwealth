/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription
} from ".";

interface Ierc777Interface extends Interface {
  functions: {
    name: TypedFunctionDescription<{ encode([]: []): string }>;

    symbol: TypedFunctionDescription<{ encode([]: []): string }>;

    granularity: TypedFunctionDescription<{ encode([]: []): string }>;

    totalSupply: TypedFunctionDescription<{ encode([]: []): string }>;

    balanceOf: TypedFunctionDescription<{ encode([owner]: [string]): string }>;

    send: TypedFunctionDescription<{
      encode([recipient, amount, data]: [
        string,
        BigNumberish,
        Arrayish
      ]): string;
    }>;

    burn: TypedFunctionDescription<{
      encode([amount, data]: [BigNumberish, Arrayish]): string;
    }>;

    isOperatorFor: TypedFunctionDescription<{
      encode([operator, tokenHolder]: [string, string]): string;
    }>;

    authorizeOperator: TypedFunctionDescription<{
      encode([operator]: [string]): string;
    }>;

    revokeOperator: TypedFunctionDescription<{
      encode([operator]: [string]): string;
    }>;

    defaultOperators: TypedFunctionDescription<{ encode([]: []): string }>;

    operatorSend: TypedFunctionDescription<{
      encode([sender, recipient, amount, data, operatorData]: [
        string,
        string,
        BigNumberish,
        Arrayish,
        Arrayish
      ]): string;
    }>;

    operatorBurn: TypedFunctionDescription<{
      encode([account, amount, data, operatorData]: [
        string,
        BigNumberish,
        Arrayish,
        Arrayish
      ]): string;
    }>;
  };

  events: {
    AuthorizedOperator: TypedEventDescription<{
      encodeTopics([operator, tokenHolder]: [
        string | null,
        string | null
      ]): string[];
    }>;

    Burned: TypedEventDescription<{
      encodeTopics([operator, from, amount, data, operatorData]: [
        string | null,
        string | null,
        null,
        null,
        null
      ]): string[];
    }>;

    Minted: TypedEventDescription<{
      encodeTopics([operator, to, amount, data, operatorData]: [
        string | null,
        string | null,
        null,
        null,
        null
      ]): string[];
    }>;

    RevokedOperator: TypedEventDescription<{
      encodeTopics([operator, tokenHolder]: [
        string | null,
        string | null
      ]): string[];
    }>;

    Sent: TypedEventDescription<{
      encodeTopics([operator, from, to, amount, data, operatorData]: [
        string | null,
        string | null,
        string | null,
        null,
        null,
        null
      ]): string[];
    }>;
  };
}

export class Ierc777 extends Contract {
  connect(signerOrProvider: Signer | Provider | string): Ierc777;
  attach(addressOrName: string): Ierc777;
  deployed(): Promise<Ierc777>;

  on(event: EventFilter | string, listener: Listener): Ierc777;
  once(event: EventFilter | string, listener: Listener): Ierc777;
  addListener(eventName: EventFilter | string, listener: Listener): Ierc777;
  removeAllListeners(eventName: EventFilter | string): Ierc777;
  removeListener(eventName: any, listener: Listener): Ierc777;

  interface: Ierc777Interface;

  functions: {
    /**
     * Returns the name of the token.
     */
    name(): Promise<string>;

    /**
     * Returns the symbol of the token, usually a shorter version of the name.
     */
    symbol(): Promise<string>;

    /**
     * Returns the smallest part of the token that is not divisible. This means all token operations (creation, movement and destruction) must have amounts that are a multiple of this number.     * For most token contracts, this value will equal 1.
     */
    granularity(): Promise<BigNumber>;

    /**
     * Returns the amount of tokens in existence.
     */
    totalSupply(): Promise<BigNumber>;

    /**
     * Returns the amount of tokens owned by an account (`owner`).
     */
    balanceOf(owner: string): Promise<BigNumber>;

    /**
     * Moves `amount` tokens from the caller's account to `recipient`.     * If send or receive hooks are registered for the caller and `recipient`, the corresponding functions will be called with `data` and empty `operatorData`. See {IERC777Sender} and {IERC777Recipient}.     * Emits a {Sent} event.     * Requirements     * - the caller must have at least `amount` tokens. - `recipient` cannot be the zero address. - if `recipient` is a contract, it must implement the {IERC777Recipient} interface.
     */
    send(
      recipient: string,
      amount: BigNumberish,
      data: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Destroys `amount` tokens from the caller's account, reducing the total supply.     * If a send hook is registered for the caller, the corresponding function will be called with `data` and empty `operatorData`. See {IERC777Sender}.     * Emits a {Burned} event.     * Requirements     * - the caller must have at least `amount` tokens.
     */
    burn(
      amount: BigNumberish,
      data: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Returns true if an account is an operator of `tokenHolder`. Operators can send and burn tokens on behalf of their owners. All accounts are their own operator.     * See {operatorSend} and {operatorBurn}.
     */
    isOperatorFor(operator: string, tokenHolder: string): Promise<boolean>;

    /**
     * Make an account an operator of the caller.     * See {isOperatorFor}.     * Emits an {AuthorizedOperator} event.     * Requirements     * - `operator` cannot be calling address.
     */
    authorizeOperator(
      operator: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Make an account an operator of the caller.     * See {isOperatorFor} and {defaultOperators}.     * Emits a {RevokedOperator} event.     * Requirements     * - `operator` cannot be calling address.
     */
    revokeOperator(
      operator: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Returns the list of default operators. These accounts are operators for all token holders, even if {authorizeOperator} was never called on them.     * This list is immutable, but individual holders may revoke these via {revokeOperator}, in which case {isOperatorFor} will return false.
     */
    defaultOperators(): Promise<string[]>;

    /**
     * Moves `amount` tokens from `sender` to `recipient`. The caller must be an operator of `sender`.     * If send or receive hooks are registered for `sender` and `recipient`, the corresponding functions will be called with `data` and `operatorData`. See {IERC777Sender} and {IERC777Recipient}.     * Emits a {Sent} event.     * Requirements     * - `sender` cannot be the zero address. - `sender` must have at least `amount` tokens. - the caller must be an operator for `sender`. - `recipient` cannot be the zero address. - if `recipient` is a contract, it must implement the {IERC777Recipient} interface.
     */
    operatorSend(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      data: Arrayish,
      operatorData: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Destoys `amount` tokens from `account`, reducing the total supply. The caller must be an operator of `account`.     * If a send hook is registered for `account`, the corresponding function will be called with `data` and `operatorData`. See {IERC777Sender}.     * Emits a {Burned} event.     * Requirements     * - `account` cannot be the zero address. - `account` must have at least `amount` tokens. - the caller must be an operator for `account`.
     */
    operatorBurn(
      account: string,
      amount: BigNumberish,
      data: Arrayish,
      operatorData: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;
  };

  /**
   * Returns the name of the token.
   */
  name(): Promise<string>;

  /**
   * Returns the symbol of the token, usually a shorter version of the name.
   */
  symbol(): Promise<string>;

  /**
   * Returns the smallest part of the token that is not divisible. This means all token operations (creation, movement and destruction) must have amounts that are a multiple of this number.     * For most token contracts, this value will equal 1.
   */
  granularity(): Promise<BigNumber>;

  /**
   * Returns the amount of tokens in existence.
   */
  totalSupply(): Promise<BigNumber>;

  /**
   * Returns the amount of tokens owned by an account (`owner`).
   */
  balanceOf(owner: string): Promise<BigNumber>;

  /**
   * Moves `amount` tokens from the caller's account to `recipient`.     * If send or receive hooks are registered for the caller and `recipient`, the corresponding functions will be called with `data` and empty `operatorData`. See {IERC777Sender} and {IERC777Recipient}.     * Emits a {Sent} event.     * Requirements     * - the caller must have at least `amount` tokens. - `recipient` cannot be the zero address. - if `recipient` is a contract, it must implement the {IERC777Recipient} interface.
   */
  send(
    recipient: string,
    amount: BigNumberish,
    data: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Destroys `amount` tokens from the caller's account, reducing the total supply.     * If a send hook is registered for the caller, the corresponding function will be called with `data` and empty `operatorData`. See {IERC777Sender}.     * Emits a {Burned} event.     * Requirements     * - the caller must have at least `amount` tokens.
   */
  burn(
    amount: BigNumberish,
    data: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Returns true if an account is an operator of `tokenHolder`. Operators can send and burn tokens on behalf of their owners. All accounts are their own operator.     * See {operatorSend} and {operatorBurn}.
   */
  isOperatorFor(operator: string, tokenHolder: string): Promise<boolean>;

  /**
   * Make an account an operator of the caller.     * See {isOperatorFor}.     * Emits an {AuthorizedOperator} event.     * Requirements     * - `operator` cannot be calling address.
   */
  authorizeOperator(
    operator: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Make an account an operator of the caller.     * See {isOperatorFor} and {defaultOperators}.     * Emits a {RevokedOperator} event.     * Requirements     * - `operator` cannot be calling address.
   */
  revokeOperator(
    operator: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Returns the list of default operators. These accounts are operators for all token holders, even if {authorizeOperator} was never called on them.     * This list is immutable, but individual holders may revoke these via {revokeOperator}, in which case {isOperatorFor} will return false.
   */
  defaultOperators(): Promise<string[]>;

  /**
   * Moves `amount` tokens from `sender` to `recipient`. The caller must be an operator of `sender`.     * If send or receive hooks are registered for `sender` and `recipient`, the corresponding functions will be called with `data` and `operatorData`. See {IERC777Sender} and {IERC777Recipient}.     * Emits a {Sent} event.     * Requirements     * - `sender` cannot be the zero address. - `sender` must have at least `amount` tokens. - the caller must be an operator for `sender`. - `recipient` cannot be the zero address. - if `recipient` is a contract, it must implement the {IERC777Recipient} interface.
   */
  operatorSend(
    sender: string,
    recipient: string,
    amount: BigNumberish,
    data: Arrayish,
    operatorData: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Destoys `amount` tokens from `account`, reducing the total supply. The caller must be an operator of `account`.     * If a send hook is registered for `account`, the corresponding function will be called with `data` and `operatorData`. See {IERC777Sender}.     * Emits a {Burned} event.     * Requirements     * - `account` cannot be the zero address. - `account` must have at least `amount` tokens. - the caller must be an operator for `account`.
   */
  operatorBurn(
    account: string,
    amount: BigNumberish,
    data: Arrayish,
    operatorData: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  filters: {
    AuthorizedOperator(
      operator: string | null,
      tokenHolder: string | null
    ): EventFilter;

    Burned(
      operator: string | null,
      from: string | null,
      amount: null,
      data: null,
      operatorData: null
    ): EventFilter;

    Minted(
      operator: string | null,
      to: string | null,
      amount: null,
      data: null,
      operatorData: null
    ): EventFilter;

    RevokedOperator(
      operator: string | null,
      tokenHolder: string | null
    ): EventFilter;

    Sent(
      operator: string | null,
      from: string | null,
      to: string | null,
      amount: null,
      data: null,
      operatorData: null
    ): EventFilter;
  };

  estimate: {
    name(): Promise<BigNumber>;

    symbol(): Promise<BigNumber>;

    granularity(): Promise<BigNumber>;

    totalSupply(): Promise<BigNumber>;

    balanceOf(owner: string): Promise<BigNumber>;

    send(
      recipient: string,
      amount: BigNumberish,
      data: Arrayish
    ): Promise<BigNumber>;

    burn(amount: BigNumberish, data: Arrayish): Promise<BigNumber>;

    isOperatorFor(operator: string, tokenHolder: string): Promise<BigNumber>;

    authorizeOperator(operator: string): Promise<BigNumber>;

    revokeOperator(operator: string): Promise<BigNumber>;

    defaultOperators(): Promise<BigNumber>;

    operatorSend(
      sender: string,
      recipient: string,
      amount: BigNumberish,
      data: Arrayish,
      operatorData: Arrayish
    ): Promise<BigNumber>;

    operatorBurn(
      account: string,
      amount: BigNumberish,
      data: Arrayish,
      operatorData: Arrayish
    ): Promise<BigNumber>;
  };
}
