/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription
} from ".";

interface Erc721Interface extends Interface {
  functions: {
    supportsInterface: TypedFunctionDescription<{
      encode([interfaceId]: [Arrayish]): string;
    }>;

    balanceOf: TypedFunctionDescription<{ encode([owner]: [string]): string }>;

    ownerOf: TypedFunctionDescription<{
      encode([tokenId]: [BigNumberish]): string;
    }>;

    approve: TypedFunctionDescription<{
      encode([to, tokenId]: [string, BigNumberish]): string;
    }>;

    getApproved: TypedFunctionDescription<{
      encode([tokenId]: [BigNumberish]): string;
    }>;

    setApprovalForAll: TypedFunctionDescription<{
      encode([to, approved]: [string, boolean]): string;
    }>;

    isApprovedForAll: TypedFunctionDescription<{
      encode([owner, operator]: [string, string]): string;
    }>;

    transferFrom: TypedFunctionDescription<{
      encode([from, to, tokenId]: [string, string, BigNumberish]): string;
    }>;

    safeTransferFrom: TypedFunctionDescription<{
      encode([from, to, tokenId]: [string, string, BigNumberish]): string;
    }>;
  };

  events: {
    Approval: TypedEventDescription<{
      encodeTopics([owner, approved, tokenId]: [
        string | null,
        string | null,
        BigNumberish | null
      ]): string[];
    }>;

    ApprovalForAll: TypedEventDescription<{
      encodeTopics([owner, operator, approved]: [
        string | null,
        string | null,
        null
      ]): string[];
    }>;

    Transfer: TypedEventDescription<{
      encodeTopics([from, to, tokenId]: [
        string | null,
        string | null,
        BigNumberish | null
      ]): string[];
    }>;
  };
}

export class Erc721 extends Contract {
  connect(signerOrProvider: Signer | Provider | string): Erc721;
  attach(addressOrName: string): Erc721;
  deployed(): Promise<Erc721>;

  on(event: EventFilter | string, listener: Listener): Erc721;
  once(event: EventFilter | string, listener: Listener): Erc721;
  addListener(eventName: EventFilter | string, listener: Listener): Erc721;
  removeAllListeners(eventName: EventFilter | string): Erc721;
  removeListener(eventName: any, listener: Listener): Erc721;

  interface: Erc721Interface;

  functions: {
    /**
     * See {IERC165-supportsInterface}.     * Time complexity O(1), guaranteed to always use less than 30 000 gas.
     */
    supportsInterface(interfaceId: Arrayish): Promise<boolean>;

    /**
     * Gets the balance of the specified address.
     * @param owner address to query the balance of
     * @returns uint256 representing the amount owned by the passed address
     */
    balanceOf(owner: string): Promise<BigNumber>;

    /**
     * Gets the owner of the specified token ID.
     * @param tokenId uint256 ID of the token to query the owner of
     * @returns address currently marked as the owner of the given token ID
     */
    ownerOf(tokenId: BigNumberish): Promise<string>;

    /**
     * Approves another address to transfer the given token ID The zero address indicates there is no approved address. There can only be one approved address per token at a given time. Can only be called by the token owner or an approved operator.
     * @param to address to be approved for the given token ID
     * @param tokenId uint256 ID of the token to be approved
     */
    approve(
      to: string,
      tokenId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Gets the approved address for a token ID, or zero if no address set Reverts if the token ID does not exist.
     * @param tokenId uint256 ID of the token to query the approval of
     * @returns address currently approved for the given token ID
     */
    getApproved(tokenId: BigNumberish): Promise<string>;

    /**
     * Sets or unsets the approval of a given operator An operator is allowed to transfer all tokens of the sender on their behalf.
     * @param approved representing the status of the approval to be set
     * @param to operator address to set the approval
     */
    setApprovalForAll(
      to: string,
      approved: boolean,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Tells whether an operator is approved by a given owner.
     * @param operator operator address which you want to query the approval of
     * @param owner owner address which you want to query the approval of
     * @returns bool whether the given operator is approved by the given owner
     */
    isApprovedForAll(owner: string, operator: string): Promise<boolean>;

    /**
     * Transfers the ownership of a given token ID to another address. Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requires the msg.sender to be the owner, approved, or operator.
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     */
    transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Safely transfers the ownership of a given token ID to another address If the target address is a contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer, and return the magic value `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise, the transfer is reverted. Requires the msg.sender to be the owner, approved, or operator
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     */
    "safeTransferFrom(address,address,uint256)"(
      from: string,
      to: string,
      tokenId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Safely transfers the ownership of a given token ID to another address If the target address is a contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer, and return the magic value `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise, the transfer is reverted. Requires the _msgSender() to be the owner, approved, or operator
     * @param _data bytes data to send along with a safe transfer check
     * @param from current owner of the token
     * @param to address to receive the ownership of the given token ID
     * @param tokenId uint256 ID of the token to be transferred
     */
    "safeTransferFrom(address,address,uint256,bytes)"(
      from: string,
      to: string,
      tokenId: BigNumberish,
      _data: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;
  };

  /**
   * See {IERC165-supportsInterface}.     * Time complexity O(1), guaranteed to always use less than 30 000 gas.
   */
  supportsInterface(interfaceId: Arrayish): Promise<boolean>;

  /**
   * Gets the balance of the specified address.
   * @param owner address to query the balance of
   * @returns uint256 representing the amount owned by the passed address
   */
  balanceOf(owner: string): Promise<BigNumber>;

  /**
   * Gets the owner of the specified token ID.
   * @param tokenId uint256 ID of the token to query the owner of
   * @returns address currently marked as the owner of the given token ID
   */
  ownerOf(tokenId: BigNumberish): Promise<string>;

  /**
   * Approves another address to transfer the given token ID The zero address indicates there is no approved address. There can only be one approved address per token at a given time. Can only be called by the token owner or an approved operator.
   * @param to address to be approved for the given token ID
   * @param tokenId uint256 ID of the token to be approved
   */
  approve(
    to: string,
    tokenId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Gets the approved address for a token ID, or zero if no address set Reverts if the token ID does not exist.
   * @param tokenId uint256 ID of the token to query the approval of
   * @returns address currently approved for the given token ID
   */
  getApproved(tokenId: BigNumberish): Promise<string>;

  /**
   * Sets or unsets the approval of a given operator An operator is allowed to transfer all tokens of the sender on their behalf.
   * @param approved representing the status of the approval to be set
   * @param to operator address to set the approval
   */
  setApprovalForAll(
    to: string,
    approved: boolean,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Tells whether an operator is approved by a given owner.
   * @param operator operator address which you want to query the approval of
   * @param owner owner address which you want to query the approval of
   * @returns bool whether the given operator is approved by the given owner
   */
  isApprovedForAll(owner: string, operator: string): Promise<boolean>;

  /**
   * Transfers the ownership of a given token ID to another address. Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requires the msg.sender to be the owner, approved, or operator.
   * @param from current owner of the token
   * @param to address to receive the ownership of the given token ID
   * @param tokenId uint256 ID of the token to be transferred
   */
  transferFrom(
    from: string,
    to: string,
    tokenId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Safely transfers the ownership of a given token ID to another address If the target address is a contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer, and return the magic value `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise, the transfer is reverted. Requires the msg.sender to be the owner, approved, or operator
   * @param from current owner of the token
   * @param to address to receive the ownership of the given token ID
   * @param tokenId uint256 ID of the token to be transferred
   */
  "safeTransferFrom(address,address,uint256)"(
    from: string,
    to: string,
    tokenId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Safely transfers the ownership of a given token ID to another address If the target address is a contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer, and return the magic value `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise, the transfer is reverted. Requires the _msgSender() to be the owner, approved, or operator
   * @param _data bytes data to send along with a safe transfer check
   * @param from current owner of the token
   * @param to address to receive the ownership of the given token ID
   * @param tokenId uint256 ID of the token to be transferred
   */
  "safeTransferFrom(address,address,uint256,bytes)"(
    from: string,
    to: string,
    tokenId: BigNumberish,
    _data: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  filters: {
    Approval(
      owner: string | null,
      approved: string | null,
      tokenId: BigNumberish | null
    ): EventFilter;

    ApprovalForAll(
      owner: string | null,
      operator: string | null,
      approved: null
    ): EventFilter;

    Transfer(
      from: string | null,
      to: string | null,
      tokenId: BigNumberish | null
    ): EventFilter;
  };

  estimate: {
    supportsInterface(interfaceId: Arrayish): Promise<BigNumber>;

    balanceOf(owner: string): Promise<BigNumber>;

    ownerOf(tokenId: BigNumberish): Promise<BigNumber>;

    approve(to: string, tokenId: BigNumberish): Promise<BigNumber>;

    getApproved(tokenId: BigNumberish): Promise<BigNumber>;

    setApprovalForAll(to: string, approved: boolean): Promise<BigNumber>;

    isApprovedForAll(owner: string, operator: string): Promise<BigNumber>;

    transferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish
    ): Promise<BigNumber>;

    safeTransferFrom(
      from: string,
      to: string,
      tokenId: BigNumberish
    ): Promise<BigNumber>;
  };
}
