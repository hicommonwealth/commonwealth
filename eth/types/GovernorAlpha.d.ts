/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription
} from ".";

interface GovernorAlphaInterface extends Interface {
  functions: {
    BALLOT_TYPEHASH: TypedFunctionDescription<{ encode([]: []): string }>;

    DOMAIN_TYPEHASH: TypedFunctionDescription<{ encode([]: []): string }>;

    comp: TypedFunctionDescription<{ encode([]: []): string }>;

    guardian: TypedFunctionDescription<{ encode([]: []): string }>;

    latestProposalIds: TypedFunctionDescription<{
      encode([]: [string]): string;
    }>;

    name: TypedFunctionDescription<{ encode([]: []): string }>;

    proposalCount: TypedFunctionDescription<{ encode([]: []): string }>;

    proposals: TypedFunctionDescription<{ encode([]: [BigNumberish]): string }>;

    timelock: TypedFunctionDescription<{ encode([]: []): string }>;

    quorumVotes: TypedFunctionDescription<{ encode([]: []): string }>;

    proposalThreshold: TypedFunctionDescription<{ encode([]: []): string }>;

    proposalMaxOperations: TypedFunctionDescription<{ encode([]: []): string }>;

    votingDelay: TypedFunctionDescription<{ encode([]: []): string }>;

    votingPeriod: TypedFunctionDescription<{ encode([]: []): string }>;

    propose: TypedFunctionDescription<{
      encode([targets, values, signatures, calldatas, description]: [
        string[],
        BigNumberish[],
        string[],
        Arrayish[],
        string
      ]): string;
    }>;

    queue: TypedFunctionDescription<{
      encode([proposalId]: [BigNumberish]): string;
    }>;

    execute: TypedFunctionDescription<{
      encode([proposalId]: [BigNumberish]): string;
    }>;

    cancel: TypedFunctionDescription<{
      encode([proposalId]: [BigNumberish]): string;
    }>;

    getActions: TypedFunctionDescription<{
      encode([proposalId]: [BigNumberish]): string;
    }>;

    getReceipt: TypedFunctionDescription<{
      encode([proposalId, voter]: [BigNumberish, string]): string;
    }>;

    state: TypedFunctionDescription<{
      encode([proposalId]: [BigNumberish]): string;
    }>;

    castVote: TypedFunctionDescription<{
      encode([proposalId, support]: [BigNumberish, boolean]): string;
    }>;

    castVoteBySig: TypedFunctionDescription<{
      encode([proposalId, support, v, r, s]: [
        BigNumberish,
        boolean,
        BigNumberish,
        Arrayish,
        Arrayish
      ]): string;
    }>;

    __acceptAdmin: TypedFunctionDescription<{ encode([]: []): string }>;

    __abdicate: TypedFunctionDescription<{ encode([]: []): string }>;

    __queueSetTimelockPendingAdmin: TypedFunctionDescription<{
      encode([newPendingAdmin, eta]: [string, BigNumberish]): string;
    }>;

    __executeSetTimelockPendingAdmin: TypedFunctionDescription<{
      encode([newPendingAdmin, eta]: [string, BigNumberish]): string;
    }>;
  };

  events: {
    ProposalCanceled: TypedEventDescription<{
      encodeTopics([id]: [null]): string[];
    }>;

    ProposalCreated: TypedEventDescription<{
      encodeTopics([
        id,
        proposer,
        targets,
        values,
        signatures,
        calldatas,
        startBlock,
        endBlock,
        description
      ]: [null, null, null, null, null, null, null, null, null]): string[];
    }>;

    ProposalExecuted: TypedEventDescription<{
      encodeTopics([id]: [null]): string[];
    }>;

    ProposalQueued: TypedEventDescription<{
      encodeTopics([id, eta]: [null, null]): string[];
    }>;

    VoteCast: TypedEventDescription<{
      encodeTopics([voter, proposalId, support, votes]: [
        null,
        null,
        null,
        null
      ]): string[];
    }>;
  };
}

export class GovernorAlpha extends Contract {
  connect(signerOrProvider: Signer | Provider | string): GovernorAlpha;
  attach(addressOrName: string): GovernorAlpha;
  deployed(): Promise<GovernorAlpha>;

  on(event: EventFilter | string, listener: Listener): GovernorAlpha;
  once(event: EventFilter | string, listener: Listener): GovernorAlpha;
  addListener(
    eventName: EventFilter | string,
    listener: Listener
  ): GovernorAlpha;
  removeAllListeners(eventName: EventFilter | string): GovernorAlpha;
  removeListener(eventName: any, listener: Listener): GovernorAlpha;

  interface: GovernorAlphaInterface;

  functions: {
    BALLOT_TYPEHASH(): Promise<string>;

    DOMAIN_TYPEHASH(): Promise<string>;

    comp(): Promise<string>;

    guardian(): Promise<string>;

    latestProposalIds(arg0: string): Promise<BigNumber>;

    name(): Promise<string>;

    proposalCount(): Promise<BigNumber>;

    proposals(
      arg0: BigNumberish
    ): Promise<{
      id: BigNumber;
      proposer: string;
      eta: BigNumber;
      startBlock: BigNumber;
      endBlock: BigNumber;
      forVotes: BigNumber;
      againstVotes: BigNumber;
      canceled: boolean;
      executed: boolean;
      0: BigNumber;
      1: string;
      2: BigNumber;
      3: BigNumber;
      4: BigNumber;
      5: BigNumber;
      6: BigNumber;
      7: boolean;
      8: boolean;
    }>;

    timelock(): Promise<string>;

    /**
     * The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed
     */
    quorumVotes(): Promise<BigNumber>;

    /**
     * The number of votes required in order for a voter to become a proposer
     */
    proposalThreshold(): Promise<BigNumber>;

    /**
     * The maximum number of actions that can be included in a proposal
     */
    proposalMaxOperations(): Promise<BigNumber>;

    /**
     * The delay before voting on a proposal may take place, once proposed
     */
    votingDelay(): Promise<BigNumber>;

    /**
     * The duration of voting on a proposal, in blocks
     */
    votingPeriod(): Promise<BigNumber>;

    propose(
      targets: string[],
      values: BigNumberish[],
      signatures: string[],
      calldatas: Arrayish[],
      description: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    queue(
      proposalId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    execute(
      proposalId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    cancel(
      proposalId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    getActions(
      proposalId: BigNumberish
    ): Promise<{
      targets: string[];
      values: BigNumber[];
      signatures: string[];
      calldatas: string[];
      0: string[];
      1: BigNumber[];
      2: string[];
      3: string[];
    }>;

    getReceipt(
      proposalId: BigNumberish,
      voter: string
    ): Promise<{
      hasVoted: boolean;
      support: boolean;
      votes: BigNumber;
      0: boolean;
      1: boolean;
      2: BigNumber;
    }>;

    state(proposalId: BigNumberish): Promise<number>;

    castVote(
      proposalId: BigNumberish,
      support: boolean,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    castVoteBySig(
      proposalId: BigNumberish,
      support: boolean,
      v: BigNumberish,
      r: Arrayish,
      s: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    __acceptAdmin(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    __abdicate(overrides?: TransactionOverrides): Promise<ContractTransaction>;

    __queueSetTimelockPendingAdmin(
      newPendingAdmin: string,
      eta: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    __executeSetTimelockPendingAdmin(
      newPendingAdmin: string,
      eta: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;
  };

  BALLOT_TYPEHASH(): Promise<string>;

  DOMAIN_TYPEHASH(): Promise<string>;

  comp(): Promise<string>;

  guardian(): Promise<string>;

  latestProposalIds(arg0: string): Promise<BigNumber>;

  name(): Promise<string>;

  proposalCount(): Promise<BigNumber>;

  proposals(
    arg0: BigNumberish
  ): Promise<{
    id: BigNumber;
    proposer: string;
    eta: BigNumber;
    startBlock: BigNumber;
    endBlock: BigNumber;
    forVotes: BigNumber;
    againstVotes: BigNumber;
    canceled: boolean;
    executed: boolean;
    0: BigNumber;
    1: string;
    2: BigNumber;
    3: BigNumber;
    4: BigNumber;
    5: BigNumber;
    6: BigNumber;
    7: boolean;
    8: boolean;
  }>;

  timelock(): Promise<string>;

  /**
   * The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed
   */
  quorumVotes(): Promise<BigNumber>;

  /**
   * The number of votes required in order for a voter to become a proposer
   */
  proposalThreshold(): Promise<BigNumber>;

  /**
   * The maximum number of actions that can be included in a proposal
   */
  proposalMaxOperations(): Promise<BigNumber>;

  /**
   * The delay before voting on a proposal may take place, once proposed
   */
  votingDelay(): Promise<BigNumber>;

  /**
   * The duration of voting on a proposal, in blocks
   */
  votingPeriod(): Promise<BigNumber>;

  propose(
    targets: string[],
    values: BigNumberish[],
    signatures: string[],
    calldatas: Arrayish[],
    description: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  queue(
    proposalId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  execute(
    proposalId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  cancel(
    proposalId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  getActions(
    proposalId: BigNumberish
  ): Promise<{
    targets: string[];
    values: BigNumber[];
    signatures: string[];
    calldatas: string[];
    0: string[];
    1: BigNumber[];
    2: string[];
    3: string[];
  }>;

  getReceipt(
    proposalId: BigNumberish,
    voter: string
  ): Promise<{
    hasVoted: boolean;
    support: boolean;
    votes: BigNumber;
    0: boolean;
    1: boolean;
    2: BigNumber;
  }>;

  state(proposalId: BigNumberish): Promise<number>;

  castVote(
    proposalId: BigNumberish,
    support: boolean,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  castVoteBySig(
    proposalId: BigNumberish,
    support: boolean,
    v: BigNumberish,
    r: Arrayish,
    s: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  __acceptAdmin(overrides?: TransactionOverrides): Promise<ContractTransaction>;

  __abdicate(overrides?: TransactionOverrides): Promise<ContractTransaction>;

  __queueSetTimelockPendingAdmin(
    newPendingAdmin: string,
    eta: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  __executeSetTimelockPendingAdmin(
    newPendingAdmin: string,
    eta: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  filters: {
    ProposalCanceled(id: null): EventFilter;

    ProposalCreated(
      id: null,
      proposer: null,
      targets: null,
      values: null,
      signatures: null,
      calldatas: null,
      startBlock: null,
      endBlock: null,
      description: null
    ): EventFilter;

    ProposalExecuted(id: null): EventFilter;

    ProposalQueued(id: null, eta: null): EventFilter;

    VoteCast(
      voter: null,
      proposalId: null,
      support: null,
      votes: null
    ): EventFilter;
  };

  estimate: {
    BALLOT_TYPEHASH(): Promise<BigNumber>;

    DOMAIN_TYPEHASH(): Promise<BigNumber>;

    comp(): Promise<BigNumber>;

    guardian(): Promise<BigNumber>;

    latestProposalIds(arg0: string): Promise<BigNumber>;

    name(): Promise<BigNumber>;

    proposalCount(): Promise<BigNumber>;

    proposals(arg0: BigNumberish): Promise<BigNumber>;

    timelock(): Promise<BigNumber>;

    quorumVotes(): Promise<BigNumber>;

    proposalThreshold(): Promise<BigNumber>;

    proposalMaxOperations(): Promise<BigNumber>;

    votingDelay(): Promise<BigNumber>;

    votingPeriod(): Promise<BigNumber>;

    propose(
      targets: string[],
      values: BigNumberish[],
      signatures: string[],
      calldatas: Arrayish[],
      description: string
    ): Promise<BigNumber>;

    queue(proposalId: BigNumberish): Promise<BigNumber>;

    execute(proposalId: BigNumberish): Promise<BigNumber>;

    cancel(proposalId: BigNumberish): Promise<BigNumber>;

    getActions(proposalId: BigNumberish): Promise<BigNumber>;

    getReceipt(proposalId: BigNumberish, voter: string): Promise<BigNumber>;

    state(proposalId: BigNumberish): Promise<BigNumber>;

    castVote(proposalId: BigNumberish, support: boolean): Promise<BigNumber>;

    castVoteBySig(
      proposalId: BigNumberish,
      support: boolean,
      v: BigNumberish,
      r: Arrayish,
      s: Arrayish
    ): Promise<BigNumber>;

    __acceptAdmin(): Promise<BigNumber>;

    __abdicate(): Promise<BigNumber>;

    __queueSetTimelockPendingAdmin(
      newPendingAdmin: string,
      eta: BigNumberish
    ): Promise<BigNumber>;

    __executeSetTimelockPendingAdmin(
      newPendingAdmin: string,
      eta: BigNumberish
    ): Promise<BigNumber>;
  };
}
