import { type Command } from '@hicommonwealth/core';
import {
  commonProtocol,
  getLaunchpadTokenDetails,
} from '@hicommonwealth/evm-protocols';
import * as schemas from '@hicommonwealth/schemas';
import { BalanceSourceType } from '@hicommonwealth/shared';
import { z } from 'zod';
import { models } from '../../database';
import { authRoles, mustExist } from '../../middleware';
import { emitEvent } from '../../utils/utils';

export function CreateToken(): Command<typeof schemas.CreateToken> {
  return {
    ...schemas.CreateToken,
    auth: [authRoles('admin')],
    body: async ({ payload }) => {
      const {
        community_id,
        eth_chain_id,
        transaction_hash,
        description,
        icon_url,
      } = payload;

      const chainNode = await models.ChainNode.findOne({
        where: { eth_chain_id },
      });
      mustExist('ChainNode', chainNode);

      const {
        name,
        symbol,
        namespace,
        token_address,
        creator_address,
        created_at,
        total_supply,
        launchpad_liquidity,
        curve_id,
        reserve_ration,
        initial_purchase_eth_amount,
      } = await getLaunchpadTokenDetails({
        rpc: chainNode.private_url! || chainNode.url!,
        transactionHash: transaction_hash,
      });

      return models.sequelize.transaction(async (transaction) => {
        const [token, created] = await models.LaunchpadToken.findOrCreate({
          where: { token_address: token_address.toLowerCase(), namespace },
          defaults: {
            token_address: token_address.toLowerCase(),
            namespace,
            name,
            symbol,
            initial_supply: Number(BigInt(total_supply) / BigInt(1e18)),
            liquidity_transferred: false,
            launchpad_liquidity: BigInt(launchpad_liquidity),
            eth_market_cap_target: commonProtocol.getTargetMarketCap(),
            description: description ?? null,
            icon_url: icon_url ?? null,
            creator_address,
          },
          transaction,
        });

        // create token holders group
        let group_id: number | undefined = undefined;
        if (community_id && created) {
          const group = await models.Group.create(
            {
              community_id,
              metadata: {
                name: `${symbol} Holders`,
                description: `Autogenerated`,
                required_requirements: 1,
              },
              requirements: [
                {
                  rule: 'threshold',
                  data: {
                    threshold: '0',
                    source: {
                      source_type: BalanceSourceType.ERC20,
                      evm_chain_id: eth_chain_id,
                      contract_address: token_address,
                    },
                  },
                },
              ],
              is_system_managed: true,
            },
            { transaction },
          );
          group_id = group.id;
        }

        // If token launch is a tokenized thread, link to thread
        if (Number(name))
          await models.sequelize.query(
            `UPDATE "Threads"
             SET launchpad_token_address = :launchpadTokenAddress,
                 is_linking_token = false
             WHERE id = :threadId
               AND is_linking_token = false;`,
            {
              replacements: {
                launchpadTokenAddress: token_address.toLowerCase(),
                threadId: name,
              },
              transaction,
            },
          );

        // emit enriched event
        if (created)
          await emitEvent(
            models.Outbox,
            [
              {
                event_name: 'LaunchpadTokenRecordCreated',
                event_payload: {
                  name,
                  symbol,
                  namespace,
                  token_address: token_address as `0x${string}`,
                  creator_address: creator_address as `0x${string}`,
                  created_at,
                  eth_chain_id,
                  total_supply,
                  launchpad_liquidity,
                  curve_id,
                  reserve_ration,
                  initial_purchase_eth_amount,
                },
              },
            ],
            transaction,
          );

        return {
          ...token!.toJSON(),
          community_id,
          group_id,
        } as unknown as z.infer<(typeof schemas.CreateToken)['output']>;
      });
    },
  };
}
