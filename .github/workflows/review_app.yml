name: Review App

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull Request Number'
        required: true
        type: number
      commit_sha:
        description: 'Override commit SHA for Docker builds (optional)'
        required: false
        type: string

jobs:
  setup_db_and_vault: # Cannot pass secrets (e.g. DB_URL) between jobs so must initialize vault here
    name: Create Review DB
    outputs:
      db_url: ${{ steps.create_neon_branch.outputs.db_url }}
      db_url_with_pooler: ${{ steps.create_neon_branch.outputs.db_url_with_pooler }}
    # Only run when a /deploy comment is created on a PR or when manually triggered
    if: |
      (github.event.issue.pull_request && github.event.comment.body == '/deploy') ||
      github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        node: [ 22 ]
    runs-on: ubuntu-latest
    steps:
      - name: Set PR Number
        id: set_pr_number
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "pr_number=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "pr_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          fi

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: refs/pull/${{ steps.set_pr_number.outputs.pr_number }}/head

      - name: Create Neon Branch
        id: create_neon_branch
        uses: neondatabase/create-branch-action@v5
        with:
          project_id: ${{ secrets.NEON_PROJECT_ID }}
          branch_name: preview/pr-${{ steps.set_pr_number.outputs.pr_number }}
          api_key: ${{ secrets.NEON_API_KEY }}
          username: 'neondb_owner'
          database: 'commonwealth'
          suspend_timeout: 300 # scale to 0 compute after 5 minutes
          ssl: require # DO NOT CHANGE THIS - we must use SSL since we are branching off prod

      - uses: ./.github/actions/setup
        if: steps.create_neon_branch.outputs.created == 'false'
        with:
          node-version: ${{ matrix.node }}

      - name: Migrate DB
        if: steps.create_neon_branch.outputs.created == 'false'
        id: migrate_db
        env:
          NODE_ENV: production
          DATABASE_URL: ${{ steps.create_neon_branch.outputs.db_url }}
        run: pnpm migrate-db

      - name: Authenticate to HCP
        uses: 'hashicorp/hcp-auth-action@v0'
        with:
          client_id: ${{ secrets.HCP_CLIENT_ID }}
          client_secret: ${{ secrets.HCP_CLIENT_SECRET }}

      - name: 'Download hcp CLI'
        uses: 'hashicorp/hcp-setup-action@v0'
        with:
          version: 'latest'

      - name: Create HCP Vault Secrets App
        uses: ./.github/actions/hcp-app-manager
        env:
          HCP_PROJECT_ID: ${{ secrets.HCP_PROJECT_ID }}
          HCP_CLIENT_ID: ${{ secrets.HCP_CLIENT_ID }}
          HCP_CLIENT_SECRET: ${{ secrets.HCP_CLIENT_SECRET }}
          DATABASE_URL: ${{ steps.create_neon_branch.outputs.db_urlwith_pooler }}
        with:
          action: 'create'
          app-name: 'PR-${{ steps.set_pr_number.outputs.pr_number }}'
          clone-app-name: 'Production' # TODO: update to beta/frick/other

      # TODO: check if this posts a new comment for each commit to an open PR if this updates the comment
      # TODO: if this creates a new comment for each commit, we need to update if so it only posts a
      # new comment when a migration changes in one of the commits since last execution
    #   - name: Post Schema Diff Comment to PR
    #     uses: neondatabase/schema-diff-action@v1
    #     if: |
    #       contains(join(github.event.issue.pull_request.changed_files.*.filename, '\n'), 'packages/commonwealth/server/migrations/')
    #     with:
    #       project_id: ${{ secrets.NEON_PROJECT_ID }}
    #       compare_branch: production # TODO: need to ensure this doesn't cause undue stress on main DB (maybe use a read replica?)
    #       api_key: ${{ secrets.NEON_API_KEY }}

  deploy_review_app:
    name: Deploy Review App
    if: |
      (github.event.issue.pull_request && github.event.comment.body == '/deploy') ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    needs: setup_db_and_vault
    strategy:
      matrix:
        node: [ 22 ]
    steps:
      - name: Set PR Number
        id: set_pr_number
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "pr_number=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "pr_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          fi

      - name: Set Effective SHA
        id: set_effective_sha
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.commit_sha }}" ]; then
            echo "sha=${{ github.event.inputs.commit_sha }}" >> $GITHUB_OUTPUT
          else
            echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: refs/pull/${{ steps.set_pr_number.outputs.pr_number }}/head

      - uses: ./.github/actions/setup
        with:
          node-version: ${{ matrix.node }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Copy .env for build
        run: |
          ENV_PATH=./packages/commonwealth/deploy/environments/.env.public.review-apps
          if [ ! -f "$ENV_PATH" ]; then
            echo "Error: $ENV_PATH not found"
            exit 1
          fi
          cp "$ENV_PATH" .env

      - name: Check if datadog-base image exists
        id: check_datadog_base_image
        run: |
          set +e
          output=$(docker manifest inspect ghcr.io/hicommonwealth/datadog-base:latest 2>&1)
          status=$?
          echo "Manifest inspect output for datadog-base:"
          echo "$output"
          echo "Exit code: $status"
          if [ $status -eq 0 ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
          exit 0

      - name: Build and Push datadog-base image
        if: steps.check_datadog_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.datadog
          push: true
          tags: ghcr.io/hicommonwealth/datadog-base:latest
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/datadog-base:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/datadog-base:buildcache,mode=max

      - name: Check if commonwealth base image exists
        id: check_base_image
        run: |
          set +e
          output=$(docker manifest inspect ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }} 2>&1)
          status=$?
          echo "Manifest inspect output for commonwealth base:"
          echo "$output"
          echo "Exit code: $status"
          if [ $status -eq 0 ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
          exit 0

      - name: Build and Push commonwealth base image
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.commonwealth_base
          target: commonwealth
          push: true
          tags: ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/datadog-base:latest
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/commonwealth:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/commonwealth:buildcache,mode=max

      # If the base image exists, we assume all other images exist and skip their builds
      - name: Build and Push Docker Image (web)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.web
          push: true
          tags: ghcr.io/hicommonwealth/web:${{ steps.set_effective_sha.outputs.sha }}
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/web:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/web:buildcache,mode=max

      - name: Build and Push Docker Image (consumer)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.consumer
          push: true
          tags: ghcr.io/hicommonwealth/consumer:${{ steps.set_effective_sha.outputs.sha }}
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/consumer:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/consumer:buildcache,mode=max

      - name: Build and Push Docker Image (discord-listener)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.discord_listener
          push: true
          tags: ghcr.io/hicommonwealth/discord-listener:${{ steps.set_effective_sha.outputs.sha }}
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/discord-listener:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/discord-listener:buildcache,mode=max

      - name: Build and Push Docker Image (evm-ce)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.evm_ce
          push: true
          tags: ghcr.io/hicommonwealth/evm-ce:${{ steps.set_effective_sha.outputs.sha }}
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/evm-ce:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/evm-ce:buildcache,mode=max

      - name: Build and Push Docker Image (graphile-worker)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.graphile_worker
          push: true
          tags: ghcr.io/hicommonwealth/graphile-worker:${{ steps.set_effective_sha.outputs.sha }}
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/graphile-worker:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/graphile-worker:buildcache,mode=max

      - name: Build and Push Docker Image (knock)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.knock
          push: true
          tags: ghcr.io/hicommonwealth/knock:${{ steps.set_effective_sha.outputs.sha }}
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/knock:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/knock:buildcache,mode=max

      - name: Build and Push Docker Image (message-relayer)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.message_relayer
          push: true
          tags: ghcr.io/hicommonwealth/message-relayer:${{ steps.set_effective_sha.outputs.sha }}
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/message-relayer:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/message-relayer:buildcache,mode=max

      - name: Build and Push Docker Image (twitter)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.twitter
          push: true
          tags: ghcr.io/hicommonwealth/twitter:${{ steps.set_effective_sha.outputs.sha }}
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/twitter:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/twitter:buildcache,mode=max

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.12.0

      # This is for accessing Terraform state in S3
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Terraform Init (Cluster)
        id: init_cluster
        working-directory: terraform/cluster
        run: |
          terraform init -backend-config="key=commonwealth-pr-environments/cluster/pr-${{ steps.set_pr_number.outputs.pr_number }}/terraform.tfstate"

      - name: Terraform Plan (Cluster)
        id: plan_cluster
        working-directory: terraform/cluster
        env:
          TF_LOG: DEBUG
        run: |
          terraform plan \
            -var="do_token=${{ secrets.DO_REVIEW_APPS_API_KEY }}" \
            -var="pr_number=${{ steps.set_pr_number.outputs.pr_number }}" \
            -out=tfplan.cluster

      - name: Terraform Apply (Cluster)
        id: apply_cluster
        working-directory: terraform/cluster
        env:
          TF_LOG: DEBUG
        run: terraform apply -auto-approve tfplan.cluster

      - name: Export Kubeconfig
        id: export_kubeconfig
        working-directory: terraform/cluster
        run: terraform output -raw kubeconfig > kubeconfig.yaml

      - name: Terraform Init (K8s)
        id: init_k8s
        working-directory: terraform/k8s
        run: |
          terraform init -backend-config="key=commonwealth-pr-environments/k8s/pr-${{ steps.set_pr_number.outputs.pr_number }}/terraform.tfstate"

      - name: Terraform Plan K8s Stage 1
        id: plan_k8s_stage1
        working-directory: terraform/k8s
        env:
          KUBECONFIG: ${{ github.workspace }}/terraform/cluster/kubeconfig.yaml
          TF_LOG: DEBUG
        run: |
          export KUBECONFIG=${{ github.workspace }}/terraform/cluster/kubeconfig.yaml
          export K8S_HOST=$(yq e '.clusters[0].cluster.server' $KUBECONFIG)
          export K8S_TOKEN=$(yq e '.users[0].user.token' $KUBECONFIG)
          export K8S_CA=$(yq e '.clusters[0].cluster.certificate-authority-data' $KUBECONFIG)
          terraform plan \
            -target="helm_release.external_secrets" \
            -target="kubernetes_namespace.cw" \
            -target="kubernetes_secret.hcp_vault_credentials" \
            -var="k8s_host=$K8S_HOST" \
            -var="k8s_token=$K8S_TOKEN" \
            -var="k8s_ca=$K8S_CA" \
            -var="hcp_client_id=${{ secrets.HCP_CLIENT_ID }}" \
            -var="hcp_client_secret=${{ secrets.HCP_CLIENT_SECRET }}" \
            -var="hcp_organization_id=${{ secrets.HCP_ORGANIZATION_ID }}" \
            -var="hcp_project_id=${{ secrets.HCP_PROJECT_ID }}" \
            -var="hcp_app_name=PR-${{ steps.set_pr_number.outputs.pr_number }}" \
            -var="image_tag=${{ steps.set_effective_sha.outputs.sha }}" \
            -var="pr_number=${{ steps.set_pr_number.outputs.pr_number }}" \
            -out=tfplan.k8s.stage1

      - name: Terraform Apply K8s Stage 1
        id: apply_k8s_stage1
        working-directory: terraform/k8s
        env:
          KUBECONFIG: ${{ github.workspace }}/terraform/cluster/kubeconfig.yaml
          TF_LOG: DEBUG
        run: |
          export KUBECONFIG=${{ github.workspace }}/terraform/cluster/kubeconfig.yaml
          terraform apply -auto-approve tfplan.k8s.stage1

      # Wait for CRDs to be ready
      - name: Wait for External Secrets CRDs
        env:
          KUBECONFIG: ${{ github.workspace }}/terraform/cluster/kubeconfig.yaml
        run: |
          echo "Waiting for External Secrets CRDs to be available..."
          kubectl wait --for condition=established --timeout=60s crd/secretstores.external-secrets.io
          kubectl wait --for condition=established --timeout=60s crd/externalsecrets.external-secrets.io
          echo "CRDs are ready!"

      - name: Terraform Plan K8s Stage 2
        id: plan_k8s
        working-directory: terraform/k8s
        env:
          KUBECONFIG: ${{ github.workspace }}/terraform/cluster/kubeconfig.yaml
          TF_LOG: DEBUG
        run: |
          export KUBECONFIG=${{ github.workspace }}/terraform/cluster/kubeconfig.yaml
          export K8S_HOST=$(yq e '.clusters[0].cluster.server' $KUBECONFIG)
          export K8S_TOKEN=$(yq e '.users[0].user.token' $KUBECONFIG)
          export K8S_CA=$(yq e '.clusters[0].cluster.certificate-authority-data' $KUBECONFIG)
          terraform plan \
            -var="k8s_host=$K8S_HOST" \
            -var="k8s_token=$K8S_TOKEN" \
            -var="k8s_ca=$K8S_CA" \
            -var="hcp_client_id=${{ secrets.HCP_CLIENT_ID }}" \
            -var="hcp_client_secret=${{ secrets.HCP_CLIENT_SECRET }}" \
            -var="hcp_organization_id=${{ secrets.HCP_ORGANIZATION_ID }}" \
            -var="hcp_project_id=${{ secrets.HCP_PROJECT_ID }}" \
            -var="hcp_app_name=PR-${{ steps.set_pr_number.outputs.pr_number }}" \
            -var="image_tag=${{ steps.set_effective_sha.outputs.sha }}" \
            -var="pr_number=${{ steps.set_pr_number.outputs.pr_number }}" \
            -out=tfplan.k8s

      # - name: Terraform Apply K8s Stage 2
      #   id: apply_k8s
      #   working-directory: terraform/k8s
      #   env:
      #     KUBECONFIG: ${{ github.workspace }}/terraform/cluster/kubeconfig.yaml
      #     TF_LOG: DEBUG
      #   run: terraform apply -auto-approve tfplan.k8s

    #   - name: Terraform Apply
    #     id: apply
    #     run: terraform apply -auto-approve tfplan

    # TODO: send kubeconfig somewhere private?
    #   - name: Export Kubeconfig
    #     run: |
    #       echo "Exporting kubeconfig to access the cluster..."
    #       terraform output -raw kubeconfig > kubeconfig.yaml
    #       echo "KUBECONFIG=$(pwd)/kubeconfig.yaml" >> $GITHUB_ENV

    #   - name: Deploy App Configuration
    #     run: |
    #       echo "Cluster is ready, web service external IP is: $(terraform output -raw web_service_ip)"
    #       echo "Adding PR comment with deployment info..."

    #   - name: Comment PR with Deployment Info
    #     uses: actions/github-script@v6
    #     with:
    #       github-token: ${{ secrets.GITHUB_TOKEN }}
    #       script: |
    #         const fs = require('fs');
    #         const output = require('child_process').execSync('terraform output -json').toString();
    #         const outputs = JSON.parse(output);
    #         const webIP = outputs.web_service_ip.value;
    #         github.rest.issues.createComment({
    #           issue_number: context.issue.number,
    #           owner: context.repo.owner,
    #           repo: context.repo.repo,
    #           body: `ðŸš€ **Review App Deployed!**\n\nYour PR environment has been successfully deployed:\n\n- **Web Application URL**: http://${webIP}\n- **Environment ID**: pr-${context.issue.number}\n- **Image Tag**: ${process.env.TF_VAR_image_tag}\n\nThis environment will be automatically deleted when the PR is closed.`
    #         });