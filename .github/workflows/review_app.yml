name: Review App Railway

on:
  issue_comment:
    types: [ created ]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull Request Number'
        required: true
        type: number
      commit_sha:
        description: 'Override commit SHA for Docker builds (optional)'
        required: false
        type: string

env:
  RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

jobs:
  build:
    name: Build Docker Containers
    if: |
      (github.event.issue.pull_request && github.event.comment.body == '/deploy') ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [ 22 ]
    steps:
      - name: Set PR Number
        id: set_pr_number
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "pr_number=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "pr_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          fi
      - name: Set Effective SHA
        id: set_effective_sha
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.commit_sha }}" ]; then
            echo "sha=${{ github.event.inputs.commit_sha }}" >> $GITHUB_OUTPUT
          else
            echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if commonwealth base image exists
        id: check_base_image
        run: |
          set +e
          output=$(docker manifest inspect ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }} 2>&1)
          status=$?
          echo "Manifest inspect output for commonwealth base:"
          echo "$output"
          echo "Exit code: $status"
          if [ $status -eq 0 ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
          exit 0

      - uses: actions/checkout@v4
        if: steps.check_base_image.outputs.exists == 'false'
        with:
          fetch-depth: 0
          ref: refs/pull/${{ steps.set_pr_number.outputs.pr_number }}/head

      - uses: ./.github/actions/setup
        if: steps.check_base_image.outputs.exists == 'false'
        with:
          node-version: ${{ matrix.node }}

      - name: Set up Docker Buildx
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/setup-buildx-action@v3

      - name: Copy .env for build
        if: steps.check_base_image.outputs.exists == 'false'
        run: |
          ENV_PATH=./packages/commonwealth/deploy/environments/.env.public.review-apps
          if [ ! -f "$ENV_PATH" ]; then
            echo "Error: $ENV_PATH not found"
            exit 1
          fi
          cp "$ENV_PATH" .env

      - name: Build and Push commonwealth base image
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.commonwealth_base
          target: commonwealth
          push: true
          tags: ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/datadog-base:latest
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/commonwealth:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/commonwealth:buildcache,mode=max

      # If the base image exists, we assume all other images exist and skip their builds
      - name: Build and Push Docker Image (web)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.web
          push: true
          tags: ghcr.io/hicommonwealth/web:${{ steps.set_effective_sha.outputs.sha }}
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.visibility=public
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/web:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/web:buildcache,mode=max

      - name: Build and Push Docker Image (consumer)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.consumer
          push: true
          tags: ghcr.io/hicommonwealth/consumer:${{ steps.set_effective_sha.outputs.sha }}
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.visibility=public
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/consumer:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/consumer:buildcache,mode=max

      - name: Build and Push Docker Image (discord-listener)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.discord_listener
          push: true
          tags: ghcr.io/hicommonwealth/discord-listener:${{ steps.set_effective_sha.outputs.sha }}
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.visibility=public
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/discord-listener:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/discord-listener:buildcache,mode=max

      - name: Build and Push Docker Image (evm-ce)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.evm_ce
          push: true
          tags: ghcr.io/hicommonwealth/evm-ce:${{ steps.set_effective_sha.outputs.sha }}
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.visibility=public
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/evm-ce:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/evm-ce:buildcache,mode=max

      - name: Build and Push Docker Image (graphile-worker)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.graphile_worker
          push: true
          tags: ghcr.io/hicommonwealth/graphile-worker:${{ steps.set_effective_sha.outputs.sha }}
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.visibility=public
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/graphile-worker:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/graphile-worker:buildcache,mode=max

      - name: Build and Push Docker Image (knock)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.knock
          push: true
          tags: ghcr.io/hicommonwealth/knock:${{ steps.set_effective_sha.outputs.sha }}
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.visibility=public
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/knock:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/knock:buildcache,mode=max

      - name: Build and Push Docker Image (message-relayer)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.message_relayer
          push: true
          tags: ghcr.io/hicommonwealth/message-relayer:${{ steps.set_effective_sha.outputs.sha }}
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.visibility=public
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/message-relayer:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/message-relayer:buildcache,mode=max

      - name: Build and Push Docker Image (twitter)
        if: steps.check_base_image.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./packages/commonwealth/deploy/dockerfiles/Dockerfile.twitter
          push: true
          tags: ghcr.io/hicommonwealth/twitter:${{ steps.set_effective_sha.outputs.sha }}
          labels: |
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.visibility=public
          build-args: |
            BASE_IMAGE=ghcr.io/hicommonwealth/commonwealth:${{ steps.set_effective_sha.outputs.sha }}
          cache-from: type=registry,ref=ghcr.io/hicommonwealth/twitter:buildcache
          cache-to: type=registry,ref=ghcr.io/hicommonwealth/twitter:buildcache,mode=max

  deploy:
    name: Deploy to Railway
    needs: build
    if: |
      (github.event.issue.pull_request && github.event.comment.body == '/deploy') ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node: [ 22 ]
    env:
      RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
    steps:
      - name: Set PR Number
        id: set_pr_number
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "pr_number=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "pr_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          fi
      - name: Set Effective SHA
        id: set_effective_sha
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.commit_sha }}" ]; then
            echo "sha=${{ github.event.inputs.commit_sha }}" >> $GITHUB_OUTPUT
          else
            echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Create Railway environment and deploy
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
          RAILWAY_PROJECT_ID: ${{ secrets.RAILWAY_PROJECT_ID }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          PR_NUMBER: ${{ steps.set_pr_number.outputs.pr_number }}
          COMMIT_SHA: ${{ steps.set_effective_sha.outputs.sha }}
          PARENT_ENV_ID: ${{ RAILWAY_PARENT_ENV_ID }}
        run: |
          node <<'EOF' 
          const RAILWAY_TOKEN = process.env.RAILWAY_TOKEN;
          const PROJECT_ID = process.env.PROJECT_ID;
          const ENV_NAME = `pr-${process.env.PR_NUMBER}`;
          const PARENT_ENV_ID = process.env.PARENT_ENV_ID;
          const COMMIT_SHA = process.env.COMMIT_SHA
          const API_URL = 'https://backboard.railway.app/graphql/v2';

          async function railwayQuery(query, variables, errorMsg) {
            const res = await (
              await fetch(API_URL, {
                method: 'POST',
                headers: {
                  Authorization: `Bearer ${RAILWAY_TOKEN}`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  query,
                  variables,
                }),
              })
            ).json();
          
            if ('errors' in res) {
              console.error(res);
              throw new Error(errorMsg);
            }
            return res;
          }
          
          async function getEnvironmentId() {
            console.log('Fetching environments...');
            const envs = await railwayQuery(
              `
                query environments($projectId: String!) {
                  environments(projectId: $projectId) {
                    edges {
                      node {
                        id
                        name
                      }
                    }
                  }
                }
              `,
              {
                projectId: PROJECT_ID,
              },
              'Failed to get environments list',
            );
          
            let envId;
            for (const edge of envs.data?.environments?.edges) {
              if (edge.node.name === ENV_NAME) {
                console.log(`Environment ${ENV_NAME} found!`);
                envId = edge.node.id;
                break;
              }
            }
          
            if (!envId) {
              console.log('Environment not found. Creating new environment...');
              const newEnv = await railwayQuery(
                `
                mutation environmentCreate($input: EnvironmentCreateInput!) {
                  environmentCreate(input: $input) {
                    id
                    name
                    projectId
                  }
                }
              `,
                {
                  input: {
                    projectId: PROJECT_ID,
                    name: ENV_NAME,
                    sourceEnvironmentId: PARENT_ENV_ID,
                  },
                },
                'Failed to create new environment',
              );
          
              if (!newEnv.data?.environmentCreate?.id) {
                console.error(newEnv);
                throw new Error('Environment id missing!');
              }
              envId = newEnv.data.environmentCreate.id;
              console.log(`Environment ${ENV_NAME} created!`);
            }
            return envId;
          }
          
          async function getServices(envId) {
            console.log('Fetching services...');
            const services = await railwayQuery(
              `
              query environment($id: String!) {
                environment(id: $id) {
                  serviceInstances {
                    edges {
                      node {
                        serviceId
                        serviceName
                      }
                    }
                  }
                }
              }
            `,
              {
                id: envId,
              },
              'Failed to fetch services',
            );
          
            const serviceMap = {};
            for (const edge of services.data?.environment?.serviceInstances?.edges) {
              serviceMap[edge.node.serviceName] = edge.node.serviceId;
            }
            if (!Object.keys(serviceMap).length) {
              throw new Error('No services found! Check the parent environment.');
            }
          
            return serviceMap;
          }
          
          async function updateServiceImage(envId, serviceId, serviceName) {
            const image = `ghcr.io/hicommonwealth/${serviceName}:${COMMIT_SHA}`;
            console.log(`Updating image for service '${serviceName}' to ${image}...`);
          
            const res = await railwayQuery(
              `
              mutation serviceInstanceUpdate($serviceId: String!, $environmentId: String, $input: ServiceInstanceUpdateInput!) {
                serviceInstanceUpdate(
                  serviceId: $serviceId
                  environmentId: $environmentId
                  input: $input
                )
              }
            `,
              {
                serviceId: serviceId,
                environmentId: envId,
                input: {
                  source: {
                    image,
                  },
                },
              },
              `Failed to update image for service ${serviceName}`,
            );
          
            console.log('Service image updated!');
            return res.data?.serviceInstanceUpdate === true;
          }
          
          async function deploy(envId, serviceId) {
            const res = await railwayQuery(
              `
              mutation serviceInstanceDeployV2($serviceId: String!, $environmentId: String!) {
                serviceInstanceDeployV2(
                  serviceId: $serviceId
                  environmentId: $environmentId
                )
              }
            `,
              {
                environmentId: envId,
                serviceId,
              },
              'Failed to deploy',
            );
          
            if (!('data' in res) || !res.data.serviceInstanceDeployV2) {
              console.error(res);
              throw new Error('Failed to get deployment id');
            }
          
            console.log('Service deploy started!');
            return res.data.serviceInstanceDeployV2;
          }
          
          async function getDeploymentStatus(deploymentId) {
            const res = await railwayQuery(
              `
              query deployment($id: String!) {
                deployment(id: $id) {
                  status
                  staticUrl
                  service {
                    name
                  }
              }
            `,
              {
                id: deploymentId,
              },
              'Failed to get deployment status',
            );
          
            if (!('data' in res) || !res.data.deployment) {
              console.log(res);
              throw new Error('Failed to get deployment status data');
            }
          
            return {
              status: res.data.deployment.status,
              url: res.data.deployment.staticUrl,
              serviceName: res.data.deployment.service?.name,
            };
          }
          
          async function waitForDeploymentCompletion(deploymentId) {
            const maxWaitTime = 1_000 * 3; // 3 minutes
            const pollInterval = 1_000 * 60; // 60 seconds - avg is 45 seconds
            const startTime = Date.now();
          
            while (Date.now() - startTime < maxWaitTime) {
              const dep = await getDeploymentStatus(deploymentId);
          
              if (['SUCCESS', 'SLEEPING'].includes(dep.status)) {
                console.log(`Deployment of '${dep.serviceName} succeeded!'`);
                return dep;
              } else if (
                [
                  'CRASHED',
                  'FAILED',
                  'REMOVED',
                  'REMOVING',
                  'NEEDS_APPROVAL',
                  'SKIPPED',
                ].includes(dep.status)
              ) {
                throw new Error(
                  `Deployment of '${dep.serviceName}' failed with status: ${dep.status}`,
                );
              }
          
              if (
                ['QUEUED', 'WAITING', 'BUILDING', 'INITIALIZING', 'DEPLOYING'].includes(
                  dep.status,
                )
              ) {
                await new Promise((resolve) => setTimeout(resolve, pollInterval));
              } else {
                throw new Error(
                  `Unknown status '${dep.status}' for service ${dep.serviceName}`,
                );
              }
            }
          
            throw new Error(`Failed to await deployment status`);
          }
          
          (async () => {
            try {
              const envId = await getEnvironmentId();
              console.log(envId);
              const serviceMap = await getServices(envId);
              console.log(serviceMap);
          
              for (const [serviceName, serviceId] of Object.entries(serviceMap)) {
                await updateServiceImage(envId, serviceId, serviceName);
              }
          
              const deploymentIds = [];
              for (const serviceId of Object.values(serviceMap)) {
                deploymentIds.push(await deploy(envId, serviceId));
              }
          
              for (const id of deploymentIds) {
                const deployment = await waitForDeploymentCompletion(id);
                if (typeof deployment.url === 'string' && deployment.url.length > 0) {
                  const fs = require('fs');
                  fs.appendFileSync(
                    process.env.GITHUB_ENV,
                    `DEPLOYMENT_URL=${deployment.url}`,
                  );
                }
              }
            } catch (e) {
              process.exit(1);
            }
          })();
          EOF

      - name: Get deployment URL
        id: deployment
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
        run: |
          # Wait for deployment to initialize
          sleep 60
          
          # Get deployment URL using the environment variables from previous step
          URL_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{\"query\": \"query { environment(id: \\\"$ENV_ID\\\") { serviceInstances { edges { node { id domains { serviceDomain customDomains { domain } } latestDeployment { status url } } } } } }\"}" \
            https://backboard.railway.app/graphql)
          
          # Try to get the service domain first, then deployment URL
          SERVICE_DOMAIN=$(echo $URL_RESPONSE | jq -r '.data.environment.serviceInstances.edges[0].node.domains.serviceDomain // empty')
          DEPLOYMENT_URL=$(echo $URL_RESPONSE | jq -r '.data.environment.serviceInstances.edges[0].node.latestDeployment.url // empty')
          
          if [ -n "$SERVICE_DOMAIN" ] && [ "$SERVICE_DOMAIN" != "null" ]; then
            echo "url=https://$SERVICE_DOMAIN" >> $GITHUB_OUTPUT
          elif [ -n "$DEPLOYMENT_URL" ] && [ "$DEPLOYMENT_URL" != "null" ]; then
            echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          else
            echo "url=Deployment in progress - check Railway dashboard" >> $GITHUB_OUTPUT
          fi

  setup_db:
    name: Create Review DB
    needs: build
    outputs:
      db_url: ${{ steps.create_neon_branch.outputs.db_url }}
      db_url_with_pooler: ${{ steps.create_neon_branch.outputs.db_url_with_pooler }}
    # Only run when a /deploy comment is created on a PR or when manually triggered
    if: |
      (github.event.issue.pull_request && github.event.comment.body == '/deploy') ||
      github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        node: [ 22 ]
    runs-on: ubuntu-latest
    steps:
      - name: Set PR Number
        id: set_pr_number
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "pr_number=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "pr_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT
          fi
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: refs/pull/${{ steps.set_pr_number.outputs.pr_number }}/head

      - name: Create Neon Branch
        id: create_neon_branch
        uses: neondatabase/create-branch-action@v5
        with:
          project_id: ${{ secrets.NEON_PROJECT_ID }}
          branch_name: preview/pr-${{ steps.set_pr_number.outputs.pr_number }}
          api_key: ${{ secrets.NEON_API_KEY }}
          username: 'neondb_owner'
          database: 'commonwealth'
          suspend_timeout: 300 # scale to 0 compute after 5 minutes
          ssl: require # DO NOT CHANGE THIS - we must use SSL since we are branching off prod

      - uses: ./.github/actions/setup
        if: steps.create_neon_branch.outputs.created == 'false'
        with:
          node-version: ${{ matrix.node }}

      - name: Migrate DB
        if: steps.create_neon_branch.outputs.created == 'false'
        id: migrate_db
        env:
          NODE_ENV: production
          DATABASE_URL: ${{ steps.create_neon_branch.outputs.db_url }}
        run: pnpm migrate-db

      # TODO: update DATABASE_URL in the Railway environment

      # TODO: check if this posts a new comment for each commit to an open PR if this updates the comment
      # TODO: if this creates a new comment for each commit, we need to update if so it only posts a
      # new comment when a migration changes in one of the commits since last execution
      #   - name: Post Schema Diff Comment to PR
      #     uses: neondatabase/schema-diff-action@v1
      #     if: |
      #       contains(join(github.event.issue.pull_request.changed_files.*.filename, '\n'), 'packages/commonwealth/server/migrations/')
      #     with:
      #       project_id: ${{ secrets.NEON_PROJECT_ID }}
      #       compare_branch: production # TODO: need to ensure this doesn't cause undue stress on main DB (maybe use a read replica?)
      #       api_key: ${{ secrets.NEON_API_KEY }}
